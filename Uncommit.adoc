:toc:
:toc-placement!:
:source-highlighter: rouge
:icons: font
:listing-caption: Listing
:xrefstyle: short
:docinfo: shared
:docinfodir: styles/
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

= Releases unused heap memory back to the OS or How to make sense of all these numbers
Volker Simonis, {docdate} {doctime}

The JVM has the ability to release unused heap memory back to the operating system. The exact details on how and when this happens depend on the selected garbage collection algorithm and can be controlled by various command line option. This blog explains how exactly releasing of memory works for SerialGC and explores the corresponding options. With the help of the built-in JVM supportability and logging facilities as well as with the help of native OS tools we will verify that the amount of virtual, committed and dirty memory of the JVM process behaves as expected.

== Heap basics

At startup the JVM determines values for the `InitialHeapSize` and `MaxHeapSize` based on the amount of system memory. These values can be inspected with `-XX:+PrintFlagsFinal`:

ifdef::env-github[TIP: You can read a much more nicely formatted version at https://simonis.github.io/Memory/Uncommit.html]

[source, console?prompt=$, options="nowrap", highlight=1]
----
$ java -XX:+UseSerialGC -XX:+PrintFlagsFinal -version | egrep '(InitialHeapSize|MaxHeapSize)'
   size_t InitialHeapSize           = 524288000                  {product} {ergonomic}
   size_t MaxHeapSize               = 8380219392                 {product} {ergonomic}
----

They can be overridden on the command line. If we want to start with 100m initial heap and not grow beyond 1g we can specify the following options:

[source, console?prompt=$, options="nowrap", highlight=1-2]
----
$ java -XX:+UseSerialGC -XX:+PrintFlagsFinal -XX:InitialHeapSize=100m -XX:MaxHeapSize=1g \
       -version | egrep '(InitialHeapSize|MaxHeapSize)'
   size_t InitialHeapSize           = 104857600                  {product} {command line}
   size_t MaxHeapSize               = 1073741824                 {product} {command line}
----

The JVM also has the notion of a minimum heap size which can be set with the `-Xms` command line option. `-Xms` will actually set both, the minimum and the initial heap size to the same value. But is also has some peculiarities: if you set both `-Xms` and `-XX:InitialHeapSize` and `-Xms` comes first on the command line than `sXms` will set the minimum and `-XX:InitialHeapSize` the initial heap size. If `-Xms` comes second, it will set both, the minimum and the initial heap size to the same value and override the effect of the `-XX:InitialHeapSize` option. To overcome this situation and make it possible to reliably and independently set both, the minimum and the initial heap size, jdk13 has introduced the new `-XX:MinHeapSize` flag (see https://bugs.openjdk.java.net/browse/JDK-8223837[JDK-8223837: Add -XX:MinHeapSize flag to set the minimum heap size]).

== Serial GC

For SerialGC, `InitialHeapSize` and `MaxHeapSize` determine the overall size of the heap (setting `-Xms` to a lower value than `InitialHeapSize` has no effect for SerialGC because the heap will never shrink below `InitialHeapSize`). The https://docs.oracle.com/en/java/javase/11/gctuning/factors-affecting-garbage-collection-performance.html[SerialGC heap] is subdivided in the New (aka. Young) and the Old (aka. "Tenured") generation. The New generation is further subdivided into the three Eden, From and To spaces. We can see these spaces for each GC cycle when we enable GC logging with `-Xlog:gc+heap`. For the remainder of this blog we will use the simple https://github.com/simonis/Memory/blob/master/examples/java/Uncommit.java[`Uncommit.java`] example program which first allocates a configurable amount of data and then calls `System.gc()` several times after the data has been freed. It also calls `System.gc()` right after invoking the `main()` function, to get a baseline for our application:

[source, console?prompt=$, options="nowrap", highlight=1-2, subs="+macros"]
----
$ java -XX:+UseSerialGC -XX:InitialHeapSize=+++<mark>100m</mark>+++ -XX:MaxHeapSize=1g -Xlog:gc+heap*=trace::none \
       Uncommit
...
Calling System.gc()
GC(0) Heap before GC invocations=0 (full 0):
GC(0)  def new generation   total +++<mark>30720K</mark>+++, used 2733K [+++<mark class="level1">0x00000000c0000000</mark>+++, +++<mark class="level1">0x00000000c2150000</mark>+++, +++<mark class="level2">0x00000000d5550000</mark>+++)
GC(0)   eden space +++<mark>27328K</mark>+++,  10% used [0x00000000c0000000, 0x00000000c02ab448, 0x00000000c1ab0000)
GC(0)   from space +++<mark>3392K</mark>+++,   0% used [0x00000000c1ab0000, 0x00000000c1ab0000, 0x00000000c1e00000)
GC(0)   to   space 3392K,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
GC(0)  tenured generation   total +++<mark>68288K</mark>+++, used 0K [+++<mark class="level2">0x00000000d5550000</mark>+++, +++<mark class="level2">0x00000000d9800000</mark>+++, +++<mark class="level2">0x0000000100000000</mark>+++)
GC(0)    the space 68288K,   0% used [0x00000000d5550000, 0x00000000d5550000, 0x00000000d5550200, 0x00000000d9800000)
...
----

Before this very first GC Eden and From sum up to New (i.e. +++<mark>27328k</mark>+++ + +++<mark>3392k</mark>+++ == +++<mark>30720k</mark>+++) and New plus Tenured plus To sum up to InitialHeapSize (i.e. +++<mark>30720k</mark>+++ + +++<mark>68288k</mark>+++ + 3392k == 102400k == +++<mark>100m</mark>+++). Notice how the size of New is given as 30720 which only includes Eden and From because out of From and To only one will be active at any given time. In reality, New occupies 34112k (i.e. Eden + From + To) and this can be easily computed from (+++<mark class="level1">0x00000000c2150000</mark>+++ - +++<mark class="level1">0x00000000c0000000</mark>+++) / 1024. 0x00000000c0000000 is the starting address of New and 0x00000000c2150000 is the end address of its currently active part (i.e. the initially committed part). The maximum reserved size of New is 349504k and it goes from 0x00000000c0000000 to 0x00000000d5550000.

For Tenured, the currently active (i.e. committed) part has a size of 68288K (from +++<mark class="level2">0x00000000d5550000</mark>+++ to +++<mark class="level2">0x00000000d9800000</mark>+++) while its reserved size (i.e. 699072k) starts at 0x00000000d5550000 and ends at +++<mark class="level2">0x0000000100000000</mark>+++. The reserved sizes for New and Tenured sum up to MaxHeapSize (i.e. 349504k + 699072k == 1048576k == 1g).

New occupies ~33% (i.e. 349504k / 1048576k == 0.33) and Tenured ~66% (i.e. 699072k / 1048576k == 0.66) of the total reserved heap which corresponds to an Old/New ratio of 2 as specified by the default value for `-XX:NewRatio`. This is also the ratio of the initially committed parts of New and Tenured (i.e. +++<mark>34112k</mark>+++ / 102400k == 0.33 for New and +++<mark>68288k</mark>+++ / 102400k == 0.66 for Tenured).

[source, console?prompt=$, options="nowrap", subs="+macros"]
----
...
GC(0) New generation size +++<mark>34112K</mark>+++->34176K [eden=27392K,survivor=3392K]
GC(0)   [+++<mark class="level1">allowed 5K extra for 1 threads</mark>+++]
GC(0) DefNew: 2733K(30720K)->0K(30784K) Eden: 2733K(27328K)->0K(27392K) From: 0K(3392K)->0K(3392K)
GC(0) Tenured: 0K(+++<mark>68288K</mark>+++)->689K(68288K)
GC(0) Heap after GC invocations=1 (full 1):
GC(0)  def new generation   total 30784K, used 0K [0x00000000c0000000, 0x00000000c2160000, 0x00000000d5550000)
GC(0)   eden space 27392K,   0% used [0x00000000c0000000, 0x00000000c0000000, 0x00000000c1ac0000)
GC(0)   from space 3392K,   0% used [0x00000000c1ac0000, 0x00000000c1ac0000, 0x00000000c1e10000)
GC(0)   to   space 3392K,   0% used [0x00000000c1e10000, 0x00000000c1e10000, 0x00000000c2160000)
GC(0)  tenured generation   total 68288K, used 689K [0x00000000d5550000, 0x00000000d9800000, 0x0000000100000000)
GC(0)    the space 68288K,   1% used [0x00000000d5550000, 0x00000000d55fc4c0, 0x00000000d55fc600, 0x00000000d9800000)
...
----

As you can see, after the first full GC, the size of New will be adjusted to accommodate the number of Java threads (1 in our case). Notice that as of the writing of this blog, a stock OpenJDK will always prints `+++<mark class="level1">"allow 0k extra for 0 threads"</mark>+++`. This logging error will be fixed by https://bugs.openjdk.java.net/browse/JDK-8270100[JDK-8270100].

To simplify further analysis we can disable this resizing by setting `-XX:NewSizeThreadIncrease` to 0. We also set `-XX:NativeMemoryTracking=summary` so we can use https://docs.oracle.com/en/java/javase/11/vm/native-memory-tracking.html[Native Memory Tracking] (NMT) to verify the GC log output:

[source, console?prompt=$, options="nowrap", highlight=1-2, subs="+macros"]
----
$ java -XX:+UseSerialGC -XX:InitialHeapSize=100m -XX:MaxHeapSize=1g -Xlog:gc+heap*=trace::none \
       -XX:NewSizeThreadIncrease=0 -XX:NativeMemoryTracking=summary Uncommit
...
GC(0) DefNew: 2733K(30720K)->0K(30720K) Eden: 2733K(27328K)->0K(27328K) From: 0K(3392K)->0K(3392K)
GC(0) Tenured: 0K(68288K)->733K(68288K)
GC(0) Heap after GC invocations=1 (full 1):
GC(0)  def new generation   total 30720K, used 0K [0x00000000c0000000, 0x00000000c2150000, 0x00000000d5550000)
GC(0)   eden space 27328K,   0% used [0x00000000c0000000, 0x00000000c0000000, 0x00000000c1ab0000)
GC(0)   from space 3392K,   0% used [0x00000000c1ab0000, 0x00000000c1ab0000, 0x00000000c1e00000)
GC(0)   to   space 3392K,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
GC(0)  tenured generation   total 68288K, used 733K [0x00000000d5550000, 0x00000000d9800000, 0x0000000100000000)
GC(0)    the space 68288K,   1% used [0x00000000d5550000, 0x00000000d56074d0, 0x00000000d5607600, 0x00000000d9800000)
...
+++<mark>VmRSS:	   40772 kB</mark>+++

Press <Enter>
----

Every time after the application calls `System.gc()` it will report the amount of memory it consumes as +++<mark>`VmRSS`</mark>+++ (based on data gathered from `/proc/self/status`) and wait for user input in order to give us a chance to analyze it with external tools. The NMT information for our application confirms the reserved (i.e.+++<mark>1048576k</mark>+++ == 1g) and committed (i.e. +++<mark>102400k</mark>+++ == 100m) heap sizes we've calculated from the GC log before:

[source, console?prompt=$, options="nowrap", highlight=1, subs="+macros"]
----
$ jcmd Uncommit VM.native_memory
...
-                 Java Heap (reserved=+++<mark>1048576KB</mark>+++, committed=+++<mark>102400KB</mark>+++)
                            (mmap: reserved=1048576KB, committed=102400KB)
...
----

But unfortunately, on Linux "committed" doesn't mean that a memory segment is backed up by real, physical memory until each of its pages was touched (i.e. written to) for the first time. This means that the corresponding pages won't show up in the so called "resident set" (i.e. RSS) of the process until they get touched. We can verify this with `pmap` command:

[source, console?prompt=$, options="nowrap", highlight=1]
----
$ pmap -x 17126
...
Address           Kbytes     RSS   Dirty Mode  Mapping
00000000c0000000   34112    1408    1408 rw---   [ anon ]    <1>
00000000c2150000  315392       0       0 -----   [ anon ]    <3>
00000000d5550000   68288     736     736 rw---   [ anon ]    <2>
00000000d9800000  630784       0       0 -----   [ anon ]    <3>
0000000800000000      12      12      12 rwx-- classes.jsa
0000000800003000    4348    4052    3140 rw--- classes.jsa
0000000800442000    7956    7632       0 r---- classes.jsa
...
---------------- ------- ------- -------
total kB         3470076   41820   14000
----

"rw" (i.e. read/write) mode means that the corresponding mapping has been committed while an empty mode indicates a virtual memory mapping which has only been reserved but not yet committed. "RSS" (i.e. resident set size) denotes the part of the corresponding mapping which is actually present in physical memory. If a virtual memory mapping is backed up by a file, the "Mapping" section contains the file name (e.g. `classes.jsa` for the CDS, i.e. class data sharing archive). For the Java heap `[ anon ]` indicates that it is an anonymous mapping. Finally, the "Dirty" column prints the amount of memory which has been changed with respect to the primary source of the mapping. For anonymous mappings like the Java heap, RSS is equal to Dirty but for file mappings like the CDS archive we can see that for writable sections some parts might still correspond to the original data in the file and Dirty \<= RSS \<= Kbytes. For read-only mappings, the application can't change the data so Dirty will always be zero (see these https://simonis.github.io/JavaZone2018/CDS/cds.xhtml#/10/1[slides] and https://vimeo.com/289644820#t=2789s[presentation] for more details about the CDS sections and layout).

For the Java heap we can see that a slice of 34112k callout:1[](which is exactly the size of "Eden + From + To") and another one of 68288k callout:2[](which corresponds to the size of Tenured) are committed while the remaining part of the heap callout:3[](315392k + 630784k == 946176k == 1048576k - 102400k == 1048576 - (34112k + 68288k)) is only reserved. The interesting and maybe surprising part of this itemization is the fact that out of the 102400k committed Java heap (as displayed by the GC log and NMT) only 2144k (i.e. 1408k + 736k) are initially mapped to physical memory and account for the process' RSS.

It is also interesting to see that for the old generation the RSS portion reported by `pmap` corresponds exactly to the used part of that region as reported by the GC log if we align it to 4k pages  callout:2[](i.e. 736k == (733k + 4k) & 0xfff8). For the new generation the 1408k RSS as reported by `pmap`  callout:1[] is much smaller than the 2733k reported by the GC log as "used". This difference is caused by a feature called "thread local allocation buffer" (TLAB) which is used to speed up allocations. It works by assigning each thread an own, private chunk of Eden such that it doesn't need to synchronize with other threads for each allocation. For the GC log, these parts of Eden count as "used", although the threads owning them might not have filled them up (i.e. touched them) completely. If we run our sample application with `-XX:-UseTLAB` we can see that the reported "used" size of +++<mark>1393k</mark>+++ for the new generation is much closer to the 1408k RSS as reported by `pmap`:

[source, console?prompt=$, options="nowrap", highlight=1-2, subs="+macros"]
----
$ java -XX:+UseSerialGC -XX:InitialHeapSize=100m -XX:MaxHeapSize=1g -Xlog:gc+heap*=trace::none \
       -XX:NewSizeThreadIncrease=0 -XX:NativeMemoryTracking=summary -XX:-UseTLAB Uncommit
...
GC(0) Heap before GC invocations=0 (full 0):
GC(0)  def new generation   total 30720K, used +++<mark>1393K</mark>+++ [0x00000000c0000000, 0x00000000c2150000, 0x00000000d5550000)
GC(0)   eden space 27328K,   5% used [0x00000000c0000000, 0x00000000c015c6a8, 0x00000000c1ab0000)
GC(0)   from space 3392K,   0% used [0x00000000c1ab0000, 0x00000000c1ab0000, 0x00000000c1e00000)
GC(0)   to   space 3392K,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
----

The size of the TLAB is adaptive but can also be specified with the `-XX:TLABSize` option. It defaults to zero which means that the initial size will be determined ergonomically. Unfortunately, this determined, initial size can only be logged in a debug build of the JVM with the command line option `-Xlog:tlab*=trace`:

[source, console?prompt=$, options="nowrap", highlight=1]
----
$ java -Xlog:tlab*=trace -version
[0.066s][trace][gc,tlab] TLAB min: 328 initial: 62914 max: 262144
...
----

To sum it up, we can see that after the first `System.gc()`, our Java process only uses ~40m of RSS (i.e. 41820k according to `pmap` and 40772k according to ``Uncommit``s output). The Java heap only contributes 2144k (i.e. 1408k + 736k) to this amount.

### Allocating memory

After pressing `<Enter>`, the sample application will allocate 512 megabaytes in chunks of `int[256]` arrays (the amount of allocated megabytes can be configured with the first command line argument). The allocations will trigger several implicit GCs and increase the committed heap to accommodate for the new data. After all the allocations have been satisfied, we get the following output:

[source, console?prompt=$, options="nowrap", subs="+macros"]
----
...
GC(24) Heap after GC invocations=21 (full 5):
GC(24)  def new generation   total +++<mark class="level1">30720K</mark>+++, used 3392K [0x00000000c0000000, 0x00000000c2150000, 0x00000000d5550000)
GC(24)   eden space +++<mark>27328K</mark>+++,   0% used [0x00000000c0000000, 0x00000000c0000000, 0x00000000c1ab0000)
GC(24)   from space +++<mark>3392K</mark>+++, 100% used [0x00000000c1ab0000, 0x00000000c1e00000, 0x00000000c1e00000)
GC(24)   to   space +++<mark>3392K</mark>+++,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
GC(24)  tenured generation   total +++<mark class="level2">699072K</mark>+++, used 530586K [0x00000000d5550000, 0x0000000100000000, 0x0000000100000000)
GC(24)    the space 699072K,  75% used [0x00000000d5550000, 0x00000000f5b76990, 0x00000000f5b76a00, 0x0000000100000000)
GC(24)  Metaspace       used 1066K, committed 1216K, reserved 1056768K
GC(24)   class space    used 101K, committed 192K, reserved 1048576K
Successfully allocated 512MB memory
VmRSS:	  605720 kB
...
----

The new generation is now using (i.e. has committed) 34112k (i.e. Eden + From + To == +++<mark>27328K</mark>+++ + +++<mark>3392K</mark>+++ + +++<mark>3392K</mark>+++ == +++<mark class="level1">30720K</mark>+++ + 3392K == 34112k) and the old generation is using +++<mark class="level2">699072k</mark>+++ which corresponds to its maximum size. These are the same numbers as reported by NMT (i.e. 699072k + 34112k == +++<mark>733184k</mark>+++):

[source, console?prompt=$, options="nowrap", subs="+macros"]
----
-                 Java Heap (reserved=1048576KB, committed=+++<mark>733184KB</mark>+++)
                            (mmap: reserved=1048576KB, committed=733184KB)
----

If we are looking at the `pmap` output, we'll see:

[source, console?prompt=$, options="nowrap"]
----
Address           Kbytes     RSS   Dirty Mode  Mapping
00000000c0000000   34112   34112   34112 rw---   [ anon ]   <1>
00000000c2150000  315392       0       0 -----   [ anon ]
00000000d5550000  699072  530588  530588 rw---   [ anon ]   <2>
0000000800000000      12      12      12 rwx-- classes.jsa
...
---------------- ------- ------- -------
total kB         3536640  607048  579104                    <3>
----

The Tenured generation is now fully committed and 530588k out of the total 699072k are mapped to physical memory callout:2[]. From the young generation, 34112k out of 315392k are committed and mapped to physical memory callout:1[]. These numbers correspond to the committed heap size reported by NMT (i.e. 699072k + 34112k == 733184k). The Java heap now contributes 564700k (i.e. 530588k + 34112k == 564700k) to the total of 607048k RSS callout:3[] (or 605720 as reported by the application) consumed by the Java process.

Pressing `<Enter>` one more time, will unlink the allocated memory and make it available for reclamation by the GC:

[source, console?prompt=$, options="nowrap"]
----
...
Successfully unlinked 512MB memory
VmRSS:	  605960 kB

Press <Enter>
...
----

Every subsequent press of `<Enter>` will trigger a new `System.gc()`. The total number of system GCs is configurable as an optional, second command line parameter and defaults to 5. We will now take a look at the `CardGeneration::compute_new_size` section in the log which we've ignored until now:

[source, options="nowrap", highlight=9..16, subs="+macros"]
----
GC(25) Heap before GC invocations=21 (full 5):
GC(25)  def new generation   total 30720K, used 14935K [0x00000000c0000000, 0x00000000c2150000, 0x00000000d5550000)
GC(25)   eden space 27328K,  42% used [0x00000000c0000000, 0x00000000c0b45ec8, 0x00000000c1ab0000)
GC(25)   from space 3392K, 100% used [0x00000000c1ab0000, 0x00000000c1e00000, 0x00000000c1e00000)
GC(25)   to   space 3392K,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
GC(25)  tenured generation   total 699072K, used +++<mark>528963K</mark>+++ [0x00000000d5550000, 0x0000000100000000, 0x0000000100000000)
GC(25)    the space 699072K,  75% used [0x00000000d5550000, 0x00000000f59e0df8, 0x00000000f59e0e00, 0x0000000100000000)

GC(25) CardGeneration::compute_new_size:
GC(25)     minimum_free_percentage:   0,40  maximum_used_percentage:   0,60
GC(25)      free_after_gc   : 671718,8K   used_after_gc   : +++<mark class="level1">27353,2K</mark>+++   capacity_after_gc   : 699072,0K
GC(25)      free_percentage:   0,96
GC(25)     maximum_free_percentage:   0,70  minimum_used_percentage:   0,30
GC(25)     _capacity_at_prologue: 699072,0K  minimum_desired_capacity: 68288,0K  maximum_desired_capacity: 91177,4K
GC(25)     shrinking:  initSize: 68288,0K  maximum_desired_capacity: +++<mark class="level2">91177,4K</mark>+++
GC(25)     shrink_bytes: 0,0K  current_shrink_factor: 0  new shrink factor: 10  _min_heap_delta_bytes: 192,0K

GC(25) DefNew: 14935K(30720K)->0K(30720K) Eden: 11543K(27328K)->0K(27328K) From: 3392K(3392K)->0K(3392K)
GC(25) Tenured: +++<mark>528963K</mark>+++(699072K)->+++<mark class="level1">27353K</mark>+++(699072K)

GC(25) Heap after GC invocations=22 (full 6):
GC(25)  def new generation   total 30720K, used 0K [0x00000000c0000000, 0x00000000c2150000, 0x00000000d5550000)
GC(25)   eden space 27328K,   0% used [0x00000000c0000000, 0x00000000c0000000, 0x00000000c1ab0000)
GC(25)   from space 3392K,   0% used [0x00000000c1ab0000, 0x00000000c1ab0000, 0x00000000c1e00000)
GC(25)   to   space 3392K,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
GC(25)  tenured generation   total 699072K, used +++<mark class="level1">27353K</mark>+++ [0x00000000d5550000, 0x0000000100000000, 0x0000000100000000)
GC(25)    the space 699072K,   3% used [0x00000000d5550000, 0x00000000d70064e0, 0x00000000d7006600, 0x0000000100000000)
Performed 1. System.gc()

VmRSS:	  603992 kB
Press <Enter>
----

This function gets called after each full GC to adjust the heap size between `InitialHeapSize` and `MaxHeapSize` if necessary. In addition to the initial and the maximum heap size it is controlled by the two parameters `MinHeapFreeRatio` which denotes the minimum percentage of heap free after GC to avoid expansion and `MaxHeapFreeRatio` which gives the maximum percentage of heap free after GC to avoid shrinking. For SerialGC the latter two parameters apply to the old generation only while for other GCs like G1 and ParallelGC they apply to the whole heap.

`MinHeapFreeRatio` (displayed as `minimum_free_percentage` in the GC log) defaults to 40% and `MaxHeapFreeRatio` (shown as `maximum_free_percentage` in the log) defaults to 70%. After this full GC cycle the used part of Tenured has dropped from +++<mark>528963k</mark>+++ to +++<mark class="level1">27353.2k</mark>+++ which leads to a free ratio of 96% (i.e. (699072k - 27353.2k) / 699072k == 0.96%). In order to compute the new size of Tenured after this GC we have to take into account that our `maximum_free_percentage` is 70%. So we set the currently `used_after_gc` amount (i.e. 27353.2k) to 30% and compute the desired size of Tenured to +++<mark class="level2">91177.4k</mark>+++ (i.e. 27353.2k / 0.30 == 91177.4). Notice that the minimal shrunken size of Tenured (i.e. `minimum_desired_capacity`) has a lower bound of 68288k which is the initially computed size of Tenured for a heap size of 100m.

This means that we could shrink Tenured after this GC cycle by 699072k - 91177k == 607895k. However, in order to avoid repetitive shrink/expand cycles, the JVM additionally damps the shrink amount (i.e. `shrink_bytes`) by a series of hard-coded shrink factors which start at 0% and increase from 10% to 40% and finally 100%. Because the initial shrink factor is 0% `shrink_bytes` evaluates to 0k which that means no heap reduction will happen after this GC. In the end, although this full GC has collected ~500m of garbage, the RSS footprint of the Java process remains almost unchanged at ~600m.

If we press `<Enter>` one more time, the second `System.gc()` will be triggered after we've unlinked the 512m of allocated memory:

[source, options="nowrap", highlight=9..17, subs="+macros"]
----
GC(26) Heap before GC invocations=22 (full 6):
GC(26)  def new generation   total 30720K, used 534K [0x00000000c0000000, 0x00000000c2150000, 0x00000000d5550000)
GC(26)   eden space 27328K,   1% used [0x00000000c0000000, 0x00000000c0085bb8, 0x00000000c1ab0000)
GC(26)   from space 3392K,   0% used [0x00000000c1ab0000, 0x00000000c1ab0000, 0x00000000c1e00000)
GC(26)   to   space 3392K,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
GC(26)  tenured generation   total 699072K, used 27353K [0x00000000d5550000, 0x0000000100000000, 0x0000000100000000)
GC(26)    the space 699072K,   3% used [0x00000000d5550000, 0x00000000d70064e0, 0x00000000d7006600, 0x0000000100000000)

GC(26) CardGeneration::compute_new_size:
GC(26)     minimum_free_percentage:   0,40  maximum_used_percentage:   0,60
GC(26)      free_after_gc   : 671718,4K   used_after_gc   : 27353,6K   capacity_after_gc   : 699072,0K
GC(26)      free_percentage:   0,96
GC(26)     maximum_free_percentage:   0,70  minimum_used_percentage:   0,30
GC(26)     _capacity_at_prologue: 699072,0K  minimum_desired_capacity: 68288,0K  maximum_desired_capacity: 91178,7K
GC(26)     shrinking:  initSize: 68288,0K  maximum_desired_capacity: +++<mark>91178,7K</mark>+++
GC(26)     shrink_bytes: +++<mark class="level2">60789,3K</mark>+++  current_shrink_factor: +++<mark class="level1">10</mark>+++  new shrink factor: 40  _min_heap_delta_bytes: 192,0K
GC(26) Shrinking tenured generation from 699072K to 638284K

GC(26) DefNew: 534K(30720K)->0K(30720K) Eden: 534K(27328K)->0K(27328K) From: 0K(3392K)->0K(3392K)
GC(26) Tenured: 27353K(699072K)->27353K(638284K)

GC(26) Heap after GC invocations=23 (full 7):
GC(26)  def new generation   total 30720K, used 0K [0x00000000c0000000, 0x00000000c2150000, 0x00000000d5550000)
GC(26)   eden space 27328K,   0% used [0x00000000c0000000, 0x00000000c0000000, 0x00000000c1ab0000)
GC(26)   from space 3392K,   0% used [0x00000000c1ab0000, 0x00000000c1ab0000, 0x00000000c1e00000)
GC(26)   to   space 3392K,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
GC(26)  tenured generation   total 638284K, used 27353K [0x00000000d5550000, 0x00000000fc4a3000, 0x0000000100000000)
GC(26)    the space 638284K,   4% used [0x00000000d5550000, 0x00000000d7006678, 0x00000000d7006800, 0x00000000fc4a3000)
Performed 2. System.gc()

VmRSS:	  604028 kB
Press <Enter>
----

This time the `maximum_desired_capacity` is +++<mark>91178.7k</mark>+++ which, together with the new shrink factor of +++<mark class="level1">10%</mark>+++, allows us to shrink (i.e. uncommit) the Tenured heap by +++<mark class="level2">60789.3k</mark>+++ (i.e. (699072k - 91178.7k) * 0.10 == 607893.3k * 0.10 == 60789.3k). Notice that although we've uncommitted ~60m of old heap, the RSS footprint of the process still remains unchanged at ~600m. This is because the 60m memory which we've just uncommitted haven't been touched before so they did not increase the memory footprint of the Java process. We can verify this by running `pmap`. After the previous, 6th full GC, the memory layout of the heap looked as follows:

[source, console?prompt=$, options="nowrap"]
----
Address           Kbytes     RSS   Dirty Mode  Mapping
00000000c0000000   34112   34112   34112 rw---   [ anon ]
00000000c2150000  315392       0       0 -----   [ anon ]
00000000d5550000  699072  528976  528976 rw---   [ anon ]  <1>
----

You can see that the whole 699072k Tenured generation is committed, but only 528976k are dirty callout:1[](i.e. have been touched). After the latest, 7th `System.gc()`, the `pmap` output looks as follows:

[source, console?prompt=$, options="nowrap"]
----
Address           Kbytes     RSS   Dirty Mode  Mapping
00000000c0000000   34112   34112   34112 rw---   [ anon ]
00000000c2150000  315392       0       0 -----   [ anon ]
00000000d5550000  638284  528976  528976 rw---   [ anon ]  <1>
00000000d90ad000   60788       0       0 -----   [ anon ]  <2>
----

As you can see, 60788k (i.e. 60789.3k aligned down to 4k pages) have now been uncommitted callout:2[], but the number of dirty pages remains the same callout:1[]. Uncommitting has no impact on the RSS footprint in this case. Let's see what happens if we trigger yet another `System.gc()`:

[source, options="nowrap", highlight=9..17, subs="+macros"]
----
GC(27) Heap before GC invocations=23 (full 7):
GC(27)  def new generation   total 30720K, used 534K [0x00000000c0000000, 0x00000000c2150000, 0x00000000d5550000)
GC(27)   eden space 27328K,   1% used [0x00000000c0000000, 0x00000000c0085bc0, 0x00000000c1ab0000)
GC(27)   from space 3392K,   0% used [0x00000000c1ab0000, 0x00000000c1ab0000, 0x00000000c1e00000)
GC(27)   to   space 3392K,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
GC(27)  tenured generation   total 638284K, used +++<mark>27354K</mark>+++ [0x00000000d5550000, 0x00000000fc4a3000, 0x0000000100000000)
GC(27)    the space 638284K,   4% used [0x00000000d5550000, 0x00000000d70068a8, 0x00000000d7006a00, 0x00000000fc4a3000)

GC(27) CardGeneration::compute_new_size:
GC(27)     minimum_free_percentage:   0,40  maximum_used_percentage:   0,60
GC(27)      free_after_gc   : 637481,5K   used_after_gc   :  802,5K   capacity_after_gc   : 638284,0K
GC(27)      free_percentage:   1,00
GC(27)     maximum_free_percentage:   0,70  minimum_used_percentage:   0,30
GC(27)     _capacity_at_prologue: 638284,0K  minimum_desired_capacity: 68288,0K  maximum_desired_capacity: 68288,0K
GC(27)     shrinking:  initSize: 68288,0K  maximum_desired_capacity: +++<mark class="level1">68288,0K</mark>+++
GC(27)     shrink_bytes: +++<mark class="level2">227998,4K</mark>+++  current_shrink_factor: +++<mark class="level2">40</mark>+++  new shrink factor: 100  _min_heap_delta_bytes: 192,0K
GC(27) Shrinking tenured generation from 638284K to 410288K

GC(27) DefNew: 534K(30720K)->0K(30720K) Eden: 534K(27328K)->0K(27328K) From: 0K(3392K)->0K(3392K)
GC(27) Tenured: +++<mark>27354K</mark>+++(638284K)->+++<mark>802K</mark>+++(410288K)

GC(27) Heap after GC invocations=24 (full 8):
GC(27)  def new generation   total 30720K, used 0K [0x00000000c0000000, 0x00000000c2150000, 0x00000000d5550000)
GC(27)   eden space 27328K,   0% used [0x00000000c0000000, 0x00000000c0000000, 0x00000000c1ab0000)
GC(27)   from space 3392K,   0% used [0x00000000c1ab0000, 0x00000000c1ab0000, 0x00000000c1e00000)
GC(27)   to   space 3392K,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
GC(27)  tenured generation   total 410288K, used +++<mark>802K</mark>+++ [0x00000000d5550000, 0x00000000ee5fc000, 0x0000000100000000)
GC(27)    the space 410288K,   0% used [0x00000000d5550000, 0x00000000d56189d8, 0x00000000d5618a00, 0x00000000ee5fc000)
Performed 3. System.gc()

VmRSS:	  484636 kB
Press <Enter>
----

This time, occupancy of Tenured after the GC has dropped from +++<mark>27354k</mark>+++ to +++<mark>802k</mark>+++. This means that we could potentially further shrink Tenured down to 2675k (i.e. 802.5 / 0.3 == 2675k) but because we have to respect the initial Tenured size as lower bound `maximum_desired_capacity` becomes +++<mark class="level1">68288k</mark>+++ which is equal to `minimum_desired_capacity`. Together with the new shrink factor of +++<mark class="level2">40%</mark>+++ this allows us to shrink the old heap by another +++<mark class="level2">227998.4k</mark>+++ (i.e. (638284k - 68288k) * 0.4 = 227998.4k). We can see that the RSS footprint of the process has now finally dropped from ~600m down to ~480m. This is still less than the ~220m we've shrunken the heap, but we know by now that it's not the amount of uncommitted memory which is crucial, but the amount of _dirty_ memory we've uncommitted.

The previous `pmap` output after the 7th full GC looked as follows:

[source, console?prompt=$, options="nowrap", subs="+macros"]
----
Address           Kbytes     RSS   Dirty Mode  Mapping
00000000c0000000   34112   34112   34112 rw---   [ anon ]
00000000c2150000  315392       0       0 -----   [ anon ]
00000000d5550000  638284  +++<mark class="level1">528976</mark>+++  528976 rw---   [ anon ]
00000000d90ad000   +++<mark>60788</mark>+++       0       0 -----   [ anon ] 
----

Comparing the previous memory map with the current one confirms these results:

[source, console?prompt=$, options="nowrap", subs="+macros"]
----
Address           Kbytes     RSS   Dirty Mode  Mapping
00000000c0000000   34112   34112   34112 rw---   [ anon ]
00000000c2150000  315392       0       0 -----   [ anon ]
00000000d5550000  410288  +++<mark class="level1">410288</mark>+++  410288 rw---   [ anon ]
00000000ee5fc000  +++<mark>288784</mark>+++       0       0 -----   [ anon ]
----

We've uncommitted an additional amount of 227996k (i.e. +++<mark>288784k</mark>+++ - +++<mark>60788k</mark>+++ == 227996k) which corresponds exactly to `shrink_bytes` aligned down to 4k pages. And this time, out of the 227996k uncommitted memory, 118688k (i.e. +++<mark class="level1">528976k</mark>+++ - +++<mark class="level1">410288k</mark>+++ == 118688k) have been dirty which correlates quite well with the observed decrease in the proecss' RSS usage from 604028k down to 484636k (i.e. 604028k - 484636k == 119392k).

After the 4th `System.gc()` we're finally down the initial Tenured size of +++<mark>68288k</mark>+++:

[source, options="nowrap", highlight=9..17, subs="+macros"]
----
GC(28) Heap before GC invocations=24 (full 8):
GC(28)  def new generation   total 30720K, used 808K [0x00000000c0000000, 0x00000000c2150000, 0x00000000d5550000)
GC(28)   eden space 27328K,   2% used [0x00000000c0000000, 0x00000000c00ca0f8, 0x00000000c1ab0000)
GC(28)   from space 3392K,   0% used [0x00000000c1ab0000, 0x00000000c1ab0000, 0x00000000c1e00000)
GC(28)   to   space 3392K,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
GC(28)  tenured generation   total 410288K, used 802K [0x00000000d5550000, 0x00000000ee5fc000, 0x0000000100000000)
GC(28)    the space 410288K,   0% used [0x00000000d5550000, 0x00000000d56189d8, 0x00000000d5618a00, 0x00000000ee5fc000)

GC(28) CardGeneration::compute_new_size:
GC(28)     minimum_free_percentage:   0,40  maximum_used_percentage:   0,60
GC(28)      free_after_gc   : 409485,2K   used_after_gc   :  802,8K   capacity_after_gc   : 410288,0K
GC(28)      free_percentage:   1,00
GC(28)     maximum_free_percentage:   0,70  minimum_used_percentage:   0,30
GC(28)     _capacity_at_prologue: 410288,0K  minimum_desired_capacity: 68288,0K  maximum_desired_capacity: 68288,0K
GC(28)     shrinking:  initSize: 68288,0K  maximum_desired_capacity: 68288,0K
GC(28)     shrink_bytes: 342000,0K  current_shrink_factor: 100  new shrink factor: 100  _min_heap_delta_bytes: 192,0K
GC(28) Shrinking tenured generation from 410288K to +++<mark>68288K</mark>+++

GC(28) DefNew: 808K(30720K)->0K(30720K) Eden: 808K(27328K)->0K(27328K) From: 0K(3392K)->0K(3392K)
GC(28) Tenured: 802K(410288K)->802K(+++<mark>68288K</mark>+++)

GC(28) Heap after GC invocations=25 (full 9):
GC(28)  def new generation   total 30720K, used 0K [0x00000000c0000000, 0x00000000c2150000, 0x00000000d5550000)
GC(28)   eden space 27328K,   0% used [0x00000000c0000000, 0x00000000c0000000, 0x00000000c1ab0000)
GC(28)   from space 3392K,   0% used [0x00000000c1ab0000, 0x00000000c1ab0000, 0x00000000c1e00000)
GC(28)   to   space 3392K,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
GC(28)  tenured generation   total +++<mark>68288K</mark>+++, used 802K [0x00000000d5550000, 0x00000000d9800000, 0x0000000100000000)
GC(28)    the space 68288K,   1% used [0x00000000d5550000, 0x00000000d5618b10, 0x00000000d5618c00, 0x00000000d9800000)
Performed 4. System.gc()

VmRSS:	  +++<mark class="level1">141304 kB</mark>+++
Press <Enter>
----

The RSS footprint has significantly dropped down to +++<mark class="level1">~140m</mark>+++ but is still significantly higher compared to the ~40m before the allocation of 512m of data by the application. The output of `pmap` shows that although the live set of Java objects in New and Tenured only requires ~800k of memory, both New and Tenured are now fully touched and dirty up to the amount of `InitialHeapSize` (i.e. +++<mark>68288k</mark>+++ + +++<mark>34112k</mark>+++ == 102400k == 100m) and contribute with 100m to the RSS footprint of the process:

[source, console?prompt=$, options="nowrap", subs="+macros"]
----
Address           Kbytes     RSS   Dirty Mode  Mapping
00000000c0000000   34112   +++<mark>34112</mark>+++   34112 rw---   [ anon ]
00000000c2150000  315392       0       0 -----   [ anon ]
00000000d5550000   68288   +++<mark>68288</mark>+++   68288 rw---   [ anon ]
00000000d9800000  630784       0       0 -----   [ anon ]
----

These 100m which correspond to the difference between the initial and the current memory usage won't go away, no matter how often we will call `System.gc()` and no matter how low the heap consumption will decrease.

== Fine tuning

=== `-XX:+AlwaysPreTouch`

The fact that Linux by default lazily maps committed, virtual memory to real, physical memory only when the corresponding memory pages get actually touched is a nice optimization which helps to save memory and CPU cycles at startup. But it also comes at a cost. Depending on the https://www.kernel.org/doc/Documentation/vm/overcommit-accounting[memory overcommit settings] an application might run into out of memory situations long time after it has reserved and committed the amount of memory it requires. Also, mapping virtual to physical pages on demand can cause unpredictable delays for certain memory accesses. To mitigate these drawbacks, the OpenJDK provides the `-XX:+AlwaysPreTouch` option (off by default) which will immediately touch (i.e. map to phyiscal memory) all the committed heap and code cache parts right at JVM startup. Enabling `-XX:+AlwaysPreTouch` slows done the startup a little bit but leads to more consistent and constant runtime behavior.

Running our example `Uncommit` application with `-XX:+AlwaysPreTouch` will result in the following GC log output for the first `System.gc()`:

[source, console?prompt=$, options="nowrap", highlight=1..2, subs="+macros"]
----
$ java -XX:+UseSerialGC -XX:InitialHeapSize=100m -XX:MaxHeapSize=1g -Xlog:gc+heap*=trace::none \
       -XX:NewSizeThreadIncrease=0 -XX:+AlwaysPreTouch Uncommit
...
GC(0) Heap after GC invocations=1 (full 1):
GC(0)  def new generation   total 30720K, used 0K [0x00000000c0000000, 0x00000000c2150000, 0x00000000d5550000)
GC(0)   eden space 27328K,   0% used [0x00000000c0000000, 0x00000000c0000000, 0x00000000c1ab0000)
GC(0)   from space 3392K,   0% used [0x00000000c1ab0000, 0x00000000c1ab0000, 0x00000000c1e00000)
GC(0)   to   space 3392K,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
GC(0)  tenured generation   total 68288K, used 733K [0x00000000d5550000, 0x00000000d9800000, 0x0000000100000000)
GC(0)    the space 68288K,   1% used [0x00000000d5550000, 0x00000000d5607500, 0x00000000d5607600, 0x00000000d9800000)
...
VmRSS:	  +++<mark>147532</mark>+++ kB
----

Compared to before when running with the default `-XX:-AlwaysPreTouch` setting, the size and occupancy of New and Tenured are exactly the same, but the RSS footprint of the whole process has increased from ~40m to +++<mark>~147m</mark>+++. Double checking with `pmap` confirms, that the committed parts of New and Tenured have the same size like before with the only difference that they are now fully dirty (i.e. completely mapped to physical pages):

[source, console?prompt=$, options="nowrap", subs="+macros"]
----
Address           Kbytes     RSS   Dirty Mode  Mapping
00000000c0000000   +++<mark>34112</mark>+++   +++<mark>34112</mark>+++   34112 rw---   [ anon ]
00000000c2150000  315392       0       0 -----   [ anon ]
00000000d5550000   +++<mark class="level1">68288</mark>+++   +++<mark class="level1">68288</mark>+++   68288 rw---   [ anon ]
00000000d9800000  630784       0       0 -----   [ anon ]
----

A careful reader might have observed that the fully touched heap only accounts for ~100m additional memory. The remaining ~7m of additional RSS memory originate from the Code Cache (used by the JIT compilers) which has now also been completely touched at startup. With `-XX:+AlwaysPreTouch` the maximum RSS footprint of our example application will increase up to ~780m (compared to ~600m before) but than decrease back to the initial ~147m after calling `System.gc()` four times.

=== `-XX:-ShrinkHeapInSteps`

As we have seen in our example, it takes four full GC cycles with SerialGC to return all non-required heap memory back to the OS. The predefined shrink factors can help to avoid oscillating heap size changes but in some situations it might be beneficial if the the application itself could fully control when heap memory will be returned to the OS. Since jdk 9 this is possible with the new `-XX:-ShrinkHeapInSteps` option which is on by default (see https://bugs.openjdk.java.net/browse/JDK-8146436[JDK-8146436: Add -XX:-ShrinkHeapInSteps option]). If `ShrinkHeapInSteps` is disabled, a call to `System.gc()` will always shrink the heap down right to the `maximum_desired_capacity` (i.e. the shrink factor will always be 100%). With this option, we will get the following log for the first `System.gc()` after the allocation:

[source, console?prompt=$, options="nowrap", highlight=1..2, subs="+macros"]
----
$ java -XX:+UseSerialGC -XX:InitialHeapSize=100m -XX:MaxHeapSize=1g -Xlog:gc+heap*=trace::none \
       -XX:NewSizeThreadIncrease=0 -XX:-ShrinkHeapInSteps Uncommit
...
GC(25) CardGeneration::compute_new_size:
GC(25)     minimum_free_percentage:   0,40  maximum_used_percentage:   0,60
GC(25)      free_after_gc   : 671718,8K   used_after_gc   : 27353,2K   capacity_after_gc   : 699072,0K
GC(25)      free_percentage:   0,96
GC(25)     maximum_free_percentage:   0,70  minimum_used_percentage:   0,30
GC(25)     _capacity_at_prologue: 699072,0K  +++<mark>minimum_desired_capacity: 68288,0K</mark>+++  maximum_desired_capacity: 91177,4K
GC(25)     shrinking:  initSize: 68288,0K  +++<mark class="level1">maximum_desired_capacity: 91177,4K</mark>+++
GC(25)     shrink_bytes: 607894,6K  current_shrink_factor: 0  new shrink factor: 0  _min_heap_delta_bytes: 192,0K
GC(25) +++<mark class="level2">Shrinking tenured generation from 699072K to 91180K</mark>+++

GC(25) DefNew: 14935K(30720K)->0K(30720K) Eden: 11543K(27328K)->0K(27328K) From: 3392K(3392K)->0K(3392K)
GC(25) Tenured: 528963K(699072K)->27353K(91180K)

GC(25) Heap after GC invocations=22 (full 6):
GC(25)  def new generation   total 30720K, used 0K [0x00000000c0000000, 0x00000000c2150000, 0x00000000d5550000)
GC(25)   eden space 27328K,   0% used [0x00000000c0000000, 0x00000000c0000000, 0x00000000c1ab0000)
GC(25)   from space 3392K,   0% used [0x00000000c1ab0000, 0x00000000c1ab0000, 0x00000000c1e00000)
GC(25)   to   space 3392K,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
GC(25)  tenured generation   total 91180K, used 27353K [0x00000000d5550000, 0x00000000dae5b000, 0x0000000100000000)
GC(25)    the space 91180K,  29% used [0x00000000d5550000, 0x00000000d70064e0, 0x00000000d7006600, 0x00000000dae5b000)
Performed 1. System.gc()

VmRSS:	  165052 kB
Press <Enter>
----

We still need a second full GC to shrink the heap to its initial size, because after the first one the computed `maximum_desired_capacity` is still bigger than the `minimum_desired_capacity`:

[source, console?prompt=$, options="nowrap", subs="+macros"]
----
...
GC(26) CardGeneration::compute_new_size:
GC(26)     minimum_free_percentage:   0,40  maximum_used_percentage:   0,60
GC(26)      free_after_gc   : 90378,1K   used_after_gc   :  801,9K   capacity_after_gc   : 91180,0K
GC(26)      free_percentage:   0,99
GC(26)     maximum_free_percentage:   0,70  minimum_used_percentage:   0,30
GC(26)     _capacity_at_prologue: 91180,0K  minimum_desired_capacity: 68288,0K  maximum_desired_capacity: 68288,0K
GC(26)     shrinking:  initSize: 68288,0K  maximum_desired_capacity: 68288,0K
GC(26)     shrink_bytes: 22892,0K  +++<mark>current_shrink_factor: 0</mark>+++  +++<mark>new shrink factor: 0</mark>+++  _min_heap_delta_bytes: 192,0K
GC(26) +++<mark class="level2">Shrinking tenured generation from 91180K to 68288K</mark>+++

GC(26) DefNew: 534K(30720K)->0K(30720K) Eden: 534K(27328K)->0K(27328K) From: 0K(3392K)->0K(3392K)
GC(26) Tenured: 27353K(91180K)->801K(68288K)

GC(26) Heap after GC invocations=23 (full 7):
GC(26)  def new generation   total 30720K, used 0K [0x00000000c0000000, 0x00000000c2150000, 0x00000000d5550000)
GC(26)   eden space 27328K,   0% used [0x00000000c0000000, 0x00000000c0000000, 0x00000000c1ab0000)
GC(26)   from space 3392K,   0% used [0x00000000c1ab0000, 0x00000000c1ab0000, 0x00000000c1e00000)
GC(26)   to   space 3392K,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
GC(26)  tenured generation   total 68288K, used 801K [0x00000000d5550000, 0x00000000d9800000, 0x0000000100000000)
GC(26)    the space 68288K,   1% used [0x00000000d5550000, 0x00000000d56187a8, 0x00000000d5618800, 0x00000000d9800000)
Performed 2. System.gc()

VmRSS:	  142032 kB
Press <Enter>
----

Notice how both, the current and the new shrink factor are misleadingly printed as zero instead of 100 although we're running with `-XX:-ShrinkHeapInSteps`. This issue will be fixed by https://bugs.openjdk.java.net/browse/JDK-8270100[JDK-8270100].

=== `-XX:MaxHeapFreeRatio`

As we've seen in the previous section, even with `-XX:-ShrinkHeapInSteps` we still need two full GC cycles to return to the initial heap layout just before the temporary allocation of 512m. This is because after the first `System.gc()` Tenured still contains 27353.2k of uncollected objects and in order to comply to the default setting of 70% `MaxHeapFreeRatio` we can't shrink Tenured below 91177.4k (i.e. 27353.2k / (1 - 0.70) == 91177.4k). However, if we relax this requirement to just 50% `MaxHeapFreeRatio` (i.e. 27353.2k / (1 - 0.50) == 54706.4k) we will be able to shrink Tenured back to its initial size right after the first full GC:

[source, console?prompt=$, options="nowrap", highlight=1..2, subs="+macros"]
----
$ java -XX:+UseSerialGC -XX:InitialHeapSize=100m -XX:MaxHeapSize=1g -Xlog:gc+heap*=trace::none \
       -XX:NewSizeThreadIncrease=0 -XX:-ShrinkHeapInSteps -XX:MaxHeapFreeRatio=50 Uncommit
...
GC(25) CardGeneration::compute_new_size:
GC(25)     minimum_free_percentage:   0,40  maximum_used_percentage:   0,60
GC(25)      free_after_gc   : 671719,0K   used_after_gc   : 27353,0K   capacity_after_gc   : 699072,0K
GC(25)      free_percentage:   0,96
GC(25)     maximum_free_percentage:   0,50  minimum_used_percentage:   0,50
GC(25)     _capacity_at_prologue: 699072,0K  minimum_desired_capacity: 68288,0K  maximum_desired_capacity: 68288,0K
GC(25)     shrinking:  initSize: 68288,0K  maximum_desired_capacity: 68288,0K
GC(25)     shrink_bytes: 630784,0K  current_shrink_factor: 0  new shrink factor: 0  _min_heap_delta_bytes: 192,0K
GC(25) +++<mark>Shrinking tenured generation from 699072K to 68288K</mark>+++

GC(25) DefNew: 14926K(30720K)->0K(30720K) Eden: 11534K(27328K)->0K(27328K) From: 3392K(3392K)->0K(3392K)
GC(25) Tenured: 529002K(699072K)->27352K(68288K)

GC(25) Heap after GC invocations=22 (full 6):
GC(25)  def new generation   total 30720K, used 0K [0x00000000c0000000, 0x00000000c2150000, 0x00000000d5550000)
GC(25)   eden space 27328K,   0% used [0x00000000c0000000, 0x00000000c0000000, 0x00000000c1ab0000)
GC(25)   from space 3392K,   0% used [0x00000000c1ab0000, 0x00000000c1ab0000, 0x00000000c1e00000)
GC(25)   to   space 3392K,   0% used [0x00000000c1e00000, 0x00000000c1e00000, 0x00000000c2150000)
GC(25)  tenured generation   total 68288K, used 27352K [0x00000000d5550000, 0x00000000d9800000, 0x0000000100000000)
GC(25)    the space 68288K,  40% used [0x00000000d5550000, 0x00000000d70063e0, 0x00000000d7006400, 0x00000000d9800000)
Performed 1. System.gc()

VmRSS:	  141464 kB
Press <Enter>
----

Choosing a smaller value for `MaxHeapFreeRatio` allows more memory to be freed from Tenured and returned back to the OS. However, the smaller we choose it, the fewer head room we leave in Tenured. This can lead to more frequent heap expansions afterwards if new allocations require more memory. We also have to ensure that `MaxHeapFreeRatio` is greater than or equal to `MinHeapFreeRatio`.

=== `-XX:InitialHeapSize`

With all the current tuning we still can't reach an RSS footprint below ~140m. This is still ~100m more than to initial RSS size before the temporary allocation of 512m of data. The reason for this difference is the fact that even though we've returned all unused Java heap memory to the OS, the remaining committed part of the heap remains completely touched (i.e. mapped to physical memory). However, if we know that our application has temporary allocation spikes (like the allocation of 512m in our example programm) but in general runs just fine with a much smaller heap, we can easily configure a significantly smaller `InitialHeapSize`. If we experimentally set `InitialHeapSize` to just 1m and both, `MinHeapFreeRatio` and `MaxHeapFreeRatio` to 10% we will get the following behavior:

[source, console?prompt=$, options="nowrap", highlight=1..3, subs="+macros"]
----
$ java -XX:+UseSerialGC -XX:InitialHeapSize=1m -XX:MaxHeapSize=1g -Xlog:gc+heap*=trace::none \
       -XX:NewSizeThreadIncrease=0 -XX:-ShrinkHeapInSteps \
       -XX:MinHeapFreeRatio=10 -XX:MaxHeapFreeRatio=10 Uncommit
...
Calling System.gc()
...
GC(1) Heap after GC invocations=2 (full 1):
GC(1)  def new generation   total 1152K, used 0K [0x00000000c0000000, 0x00000000c0140000, 0x00000000d5550000)
GC(1)   eden space +++<mark>1024K</mark>+++,   0% used [0x00000000c0000000, 0x00000000c0000000, 0x00000000c0100000)
GC(1)   from space +++<mark>128K</mark>+++,   0% used [0x00000000c0120000, 0x00000000c0120000, 0x00000000c0140000)
GC(1)   to   space +++<mark>128K</mark>+++,   0% used [0x00000000c0100000, 0x00000000c0100000, 0x00000000c0120000)
GC(1)  tenured generation   total 768K, used 736K [0x00000000d5550000, 0x00000000d5610000, 0x0000000100000000)
GC(1)    the space +++<mark class="level1">768K</mark>+++,  95% used [0x00000000d5550000, 0x00000000d56080b8, 0x00000000d5608200, 0x00000000d5610000)
...
VmRSS:	   +++<mark class="level2">40288</mark>+++ kB

Press <Enter>
...
----

Before the allocation of 512m, the young generation is now just 1280k (i.e. +++<mark>1024k</mark>+++ + +++<mark>128k</mark>+++ + +++<mark>128k</mark>+++ = 1280k) and Tenured just +++<mark class="level1">768k</mark>+++. Notice that the JVM already ran an implicit GC before we explicitly called `System.gc()` for the first time to free some space in the small, one megabyte large initial heap. The overall RSS footprint of the process is still +++<mark class="level2">~40m</mark>+++.

[source, console?prompt=$, options="nowrap", subs="+macros"]
----
...
GC(+++<mark class="level1">597</mark>+++) Heap after GC invocations=555 (full +++<mark class="level2">44</mark>+++):
GC(597)  def new generation   total 1152K, used 128K [0x00000000c0000000, 0x00000000c0140000, 0x00000000d5550000)
GC(597)   eden space 1024K,   0% used [0x00000000c0000000, 0x00000000c0000000, 0x00000000c0100000)
GC(597)   from space 128K, 100% used [0x00000000c0100000, 0x00000000c0120000, 0x00000000c0120000)
GC(597)   to   space 128K,   0% used [0x00000000c0120000, 0x00000000c0120000, 0x00000000c0140000)
GC(597)  tenured generation   total 584356K, used 542504K [0x00000000d5550000, 0x00000000f8ff9000, 0x0000000100000000)
GC(597)    the space 584356K,  92% used [0x00000000d5550000, 0x00000000f671a368, 0x00000000f671a400, 0x00000000f8ff9000)
...
Successfully allocated 512MB memory
VmRSS:	  +++<mark>584388 kB</mark>+++

Press <Enter>
----

After the allocation of 512m of data, the RSS usage of +++<mark>~580m</mark>+++ is slightly smaller compared to the ~600m before (with the default settings for `MinHeapFreeRatio` and `MaxHeapFreeRatio` and an `InitialHeapSize` of 100m). However, notice how with these somehow _extreme_ settings, the JVM already had to run +++<mark class="level1">597</mark>+++ implicit garbage collections (out of which +++<mark class="level2">44</mark>+++ were full GCs) to allow the allocation of 512m data. With the default settings and 100m `InitialHeapSize` only 24 implicit GCs (with 5 full ones) were necessary.

On the other hand, the first full GC after the allocation (i.e. +++<mark class="level2">full 45</mark>+++) now instantly reduces the RSS footprint back to +++<mark>~42m</mark>+++ which is only minimally higher compared to the ~40m before the allocation:

[source, console?prompt=$, options="nowrap", subs="+macros"]
----
...
GC(598) Shrinking tenured generation from 584356K to 2712K
GC(598) DefNew: 1110K(1152K)->0K(1152K) Eden: 982K(1024K)->0K(1024K) From: 128K(128K)->0K(128K)
GC(598) Tenured: 542504K(584356K)->2439K(2712K)
GC(598) Heap after GC invocations=556 (+++<mark class="level2">full 45</mark>+++):
GC(598)  def new generation   total 1152K, used 0K [0x00000000c0000000, 0x00000000c0140000, 0x00000000d5550000)
GC(598)   eden space 1024K,   0% used [0x00000000c0000000, 0x00000000c0000000, 0x00000000c0100000)
GC(598)   from space 128K,   0% used [0x00000000c0100000, 0x00000000c0100000, 0x00000000c0120000)
GC(598)   to   space 128K,   0% used [0x00000000c0120000, 0x00000000c0120000, 0x00000000c0140000)
GC(598)  tenured generation   total 2712K, used 2439K [0x00000000d5550000, 0x00000000d57f6000, 0x0000000100000000)
GC(598)    the space 2712K,  89% used [0x00000000d5550000, 0x00000000d57b1d40, 0x00000000d57b1e00, 0x00000000d57f6000)
...
Performed 1. System.gc()

VmRSS:	   +++<mark>42660 kB</mark>+++
Press <Enter>
----

== Summary

In the end, we can tune Serial GC to either always consume just the absolutely required minimum heap memory (which results in increased CPU usage due to more frequent GCs) or to favor fewer GC cycles at the expense of a higher memory footprint. It's up to the user to choose the right balance for his application and runtime environment.

We've also seen that configuring and tuning the JVM can be quite tricky. Always make sure that the numbers you measure really match up, never believe just a single source of information and always try to double check your results at different levels with different tools :)


////
;; indent block of text
;; C-u <number> C-x <TAB>

;; select this code and do 'M-x eval-region'
(defun make-fragment (p1 p2)
  "Wraps the selection into 'fragment' <span>s and quotes '&', '<' and '>'."
  (interactive "r")
  (setq inputStr (buffer-substring-no-properties p1 p2))
  (setq inputStr (replace-regexp-in-string "&" "&amp;" inputStr))
  (setq inputStr (replace-regexp-in-string "<" "&lt;" inputStr))
  (setq inputStr (replace-regexp-in-string ">" "&gt;" inputStr))
  (setq resultStr (concat "<span class=\"fragment\">" (concat inputStr "</span>")))
  (delete-region p1 p2)
  (insert resultStr)
)
(defun make-fragment-simple (p1 p2)
  "Wraps the selection into 'fragment' <span>s without any quoting."
  (interactive "r")
  (setq inputStr (buffer-substring-no-properties p1 p2))
  (setq resultStr (concat "<span class=\"fragment\">" (concat inputStr "</span>")))
  (delete-region p1 p2)
  (insert resultStr)
)
(defun quote-fragment (p1 p2)
  "Quotes '&', '<' and '>'."
  (interactive "r")
  (setq inputStr (buffer-substring-no-properties p1 p2))
  (setq inputStr (replace-regexp-in-string "&" "&amp;" inputStr))
  (setq inputStr (replace-regexp-in-string "<" "&lt;" inputStr))
  (setq inputStr (replace-regexp-in-string ">" "&gt;" inputStr))
  (delete-region p1 p2)
  (insert inputStr)
)
(defun make-highlight (p1 p2)
  "Wraps the selection into 'fragment' <span>s without any quoting."
  (interactive "r")
  (setq inputStr (buffer-substring-no-properties p1 p2))
  (setq resultStr (concat "+++<mark>" (concat inputStr "</mark>+++")))
  (delete-region p1 p2)
  (insert resultStr)
)
(defun make-highlight1 (p1 p2)
  "Wraps the selection into 'fragment' <span>s without any quoting."
  (interactive "r")
  (setq inputStr (buffer-substring-no-properties p1 p2))
  (setq resultStr (concat "+++<mark class=\"level1\">" (concat inputStr "</mark>+++")))
  (delete-region p1 p2)
  (insert resultStr)
)
(defun make-highlight2 (p1 p2)
  "Wraps the selection into 'fragment' <span>s without any quoting."
  (interactive "r")
  (setq inputStr (buffer-substring-no-properties p1 p2))
  (setq resultStr (concat "+++<mark class=\"level2\">" (concat inputStr "</mark>+++")))
  (delete-region p1 p2)
  (insert resultStr)
)

(global-set-key (kbd "C-f") 'make-highlight)
(global-set-key (kbd "C-S-f") 'make-highlight1)
(global-set-key (kbd "C-S-q") 'make-highlight2)
;; revert key-binding
;; (global-set-key (kbd "C-f") 'forward-char)
;;
;; use 'C-h k <keystroke>' to find out what <keystroke> is currently bound to

;; (vhs) The following is required to make 'C-c C-t' insert <code> tags without
;; newlines. 'sgml-tag-alist' is the "file-local" version of 'html-tag-alist'
(add-to-list 'html-tag-alist '("code"))
(add-to-list 'sgml-tag-alist '("code"))
////